<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Agua Abajo... y al Espacio!</title>
    <style>
        :root {
            --water-height: 20vh;
            --player-size: 10vmin;
            --item-size: 6vmin;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { width: 100%; height: 100%; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }
        body {
            background: linear-gradient(to bottom, #87CEEB 0%, #B2FFFF 80%);
            position: relative; display: flex; justify-content: center; align-items: center; flex-direction: column; transition: background 1s;
        }
        body.space-mode { background: #000; }
        #game-container { position: relative; width: 100%; height: 100%; max-width: 1000px; overflow: hidden; cursor: pointer; }

        #score, #level, #powerup-status, #cash, #health, #game-over {
            position: absolute; left: 15px; font-weight: bold; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); z-index: 100;
        }
        #score { top: 15px; font-size: 3em; }
        #level { top: 70px; font-size: 1.5em; }
        #powerup-status { top: 110px; font-size: 2em; }
        #cash { top: 150px; font-size: 1.5em; }
        #health { top: 15px; font-size: 2em; }
        #game-over { top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 3em; text-align: center; width: 100%; }

        #instructions { position: absolute; top: 20px; right: 20px; color: white; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); text-align: right; z-index: 100; }
        .hidden { display: none !important; }

        #water {
            position: absolute; bottom: 0; left: 0; width: 100%; height: var(--water-height);
            background-color: #1E90FF; overflow: hidden; transition: background-color 0.5s, opacity 1s;
        }
        #water.frozen { background-color: #AFEEEE; }
        #water.frozen::before, #water.frozen::after { animation-play-state: paused; opacity: 0.7; }
        #water::before, #water::after {
            content: ''; position: absolute; width: 200%; height: 100px; left: -50%; top: -50px;
            background-repeat: repeat-x; background-size: 50% 100px; animation: wave 10s linear infinite;
        }
        #water::before { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' preserveAspectRatio='none'%3E%3Cpath d='M0,50 C25,80 75,20 100,50 L100,100 L0,100 Z' fill='rgba(255,255,255,0.2)'/%3E%3C/svg%3E"); z-index: 10; }
        #water::after { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' preserveAspectRatio='none'%3E%3Cpath d='M0,60 C30,40 70,80 100,60 L100,100 L0,100 Z' fill='rgba(255,255,255,0.3)'/%3E%3C/svg%3E"); animation-direction: reverse; z-index: 9; }
        @keyframes wave { 0% { transform: translateX(0); } 100% { transform: translateX(-50%); } }

        #player {
            position: absolute; width: var(--player-size); height: var(--player-size); bottom: calc(var(--water-height) - (var(--player-size) / 2)); left: 50%;
            transform: translateX(-50%); font-size: calc(var(--player-size) * 0.8); text-align: center; line-height: var(--player-size); z-index: 20; transition: left 0.1s linear, bottom 1s;
        }
        .item { position: absolute; width: var(--item-size); height: var(--item-size); font-size: calc(var(--item-size) * 0.9); text-align: center; line-height: var(--item-size); user-select: none; z-index: 5; transition: left 0.2s linear; }
        .projectile { position: absolute; width: 10px; height: 25px; background-color: #FFD700; border-radius: 5px; z-index: 15; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="score">0</div>
        <div id="level">Nivel: 1</div>
        <div id="powerup-status" class="hidden"></div>
        <div id="cash">üí∞ 0</div>
        <div id="health" class="hidden"></div>
        <div id="game-over" class="hidden">GAME OVER</div>
        <div id="instructions">
            <p>‚Üê ‚Üí para mover</p>
            <p>Toca para mover en m√≥vil</p>
        </div>
        <div id="player"></div>
        <div id="water"></div>
        <button id="test-space-btn" style="position:absolute; top:10px; right:150px; z-index:200; padding: 5px; background: #fff; border: 1px solid #000; cursor: pointer;">Test Space Level</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const ALL_ELEMENTS = {
                gameContainer: document.getElementById('game-container'),
                player: document.getElementById('player'),
                score: document.getElementById('score'),
                level: document.getElementById('level'),
                powerupStatus: document.getElementById('powerup-status'),
                cash: document.getElementById('cash'),
                water: document.getElementById('water'),
                health: document.getElementById('health'),
                gameOver: document.getElementById('game-over'),
                instructions: document.getElementById('instructions')
            };

            let gameState = {
                gameMode: 'water', score: 0, cash: 0, currentLevel: 1, currentBoatIndex: 0, playerPosition: 50, playerPositionY: 50, playerHealth: 3, spaceShipLevel: 1,
                playerSpeed: 2, itemIntervalId: null, gameLoopId: null, survivalScoreId: null, canShoot: true,
                isMagnetActive: false, magnetTimerId: null, isPlayerSlowed: false, slowTimerId: null,
                projectiles: [], keysPressed: { ArrowLeft: false, ArrowRight: false, ArrowUp: false, ArrowDown: false, ' ': false }
            };

            const levelModules = {
                water: {
                    playerEmoji: 'üö§',
                    background: 'linear-gradient(to bottom, #87CEEB 0%, #B2FFFF 80%)',
                    itemTypes: [ { emoji: 'üíé', value: 50, name: 'treasure' }, { emoji: 'üçé', value: 10, name: 'fruit' }, { emoji: 'üçå', value: 10, name: 'fruit' }, { emoji: 'üí∞', value: 0, cash: 50, name: 'cash', chance: 0.18 }, { emoji: '‚Çø', value: 0, cash: 200, name: 'cash', chance: 0.02 }, { emoji: 'üóëÔ∏è', value: -25, name: 'trash' }, { emoji: 'üë¢', value: -10, name: 'trash' }, { emoji: 'üß≤', value: 0, name: 'powerup', subType: 'magnet', chance: 0.1 }, { emoji: 'üßä', value: -5, name: 'trap', subType: 'freeze', chance: 0.05 } ],
                    config: CONSTANTS.LEVEL_CONFIG,
                    update: handleMagnetPull
                },
                space: {
                    playerEmoji: 'üöÄ',
                    background: '#000',
                    itemTypes: [ { emoji: '‚òÑÔ∏è', name: 'asteroid', chance: 0.75 }, { emoji: 'üëΩ', name: 'alien', chance: 0.1 }, { emoji: '‚≠ê', value: 50, name: 'star', chance: 0.1 }, { emoji: 'üî©', name: 'upgrade', chance: 0.05 } ],
                    config: { minSpeed: 2, maxSpeed: 8 },
                    update: () => { updateProjectiles(); shoot(); }
                },
                earth: {
                    playerEmoji: 'üöó',
                    background: '#666',
                    itemTypes: [ { emoji: 'üí∞', cash: 100, name: 'cash', chance: 0.7 }, { emoji: 'üöô', value: -200, name: 'obstacle', chance: 0.3 } ],
                    config: { minSpeed: 2, maxSpeed: 6 },
                    update: () => {}
                }
            };

            const LevelManager = {
                levelSequence: ['water', 'space', 'earth'],
                currentLevelIndex: 0,
                getCurrentLevel() {
                    return this.levelSequence[this.currentLevelIndex];
                },
                getCurrentLevelModule() {
                    return levelModules[this.getCurrentLevel()];
                },
                nextLevel() {
                    if (this.currentLevelIndex < this.levelSequence.length - 1) {
                        this.currentLevelIndex++;
                        return true;
                    }
                    return false;
                }
            };

                        function createItem() {

                            const levelModule = LevelManager.getCurrentLevelModule();

                            const itemData = getRandomItem(levelModule.itemTypes);

                            const itemElement = document.createElement('div');

                            itemElement.classList.add('item');

                            itemElement.dataset.name = itemData.name;

                            if(itemData.subType) itemElement.dataset.subType = itemData.subType;

                            itemElement.textContent = itemData.emoji;

                            const config = (LevelManager.getCurrentLevel() === 'water') ? levelModule.config[gameState.currentLevel] : levelModule.config;

                            const speed = Math.random() * (config.maxSpeed - config.minSpeed) + config.minSpeed;

            

                            if (LevelManager.getCurrentLevel() === 'earth') {

                                itemElement.style.left = '100%';

                                itemElement.style.top = `${Math.random() * 90}%`;

                            } else {

                                itemElement.style.left = `${Math.random() * 95}%`;

                                itemElement.style.top = `-${parseInt(getComputedStyle(itemElement).height)}px`;

                            }

            

                            ALL_ELEMENTS.gameContainer.appendChild(itemElement);

                            moveItem(itemElement, speed, itemData);

                        }

            

                        function moveItem(element, speed, itemData) {

                            if (LevelManager.getCurrentLevel() === 'earth') {

                                let leftPosition = 100;

                                function frame() {

                                    leftPosition -= speed / 2;

                                    element.style.left = `${leftPosition}%`;

                                    if (checkCollision(element)) return;

                                    if (leftPosition < -10) { element.remove(); return; }

                                    requestAnimationFrame(frame);

                                }

                                requestAnimationFrame(frame);

                            } else {

                                let topPosition = element.offsetTop;

                                function frame() {

                                    topPosition += speed;

                                    element.style.top = `${topPosition}px`;

                                    if (checkCollision(element)) return;

                                    if (topPosition > window.innerHeight) { element.remove(); return; }

                                    requestAnimationFrame(frame);

                                }

                                requestAnimationFrame(frame);

                            }

            

                            function checkCollision(el) {

                                const playerRect = ALL_ELEMENTS.player.getBoundingClientRect();

                                const itemRect = el.getBoundingClientRect();

                                if (itemRect.bottom > playerRect.top && itemRect.top < playerRect.bottom && itemRect.right > playerRect.left && itemRect.left < playerRect.right) {

                                    handleCollision(itemData, el);

                                    return true;

                                }

                                return false;

                            }

                        }

            

                        function handleCollision(itemData, itemElement) {

                            itemElement.remove();

                            const gameMode = LevelManager.getCurrentLevel();

            

                            if (gameMode === 'water') {

                                if (itemData.name === 'powerup' && itemData.subType === 'magnet') activateMagnet();

                                else if (itemData.name === 'trap' && itemData.subType === 'freeze') activateSlowDebuff();

                                else if (itemData.name === 'cash') updateCash(itemData.cash);

                                else updateScore(itemData.value);

                            } else if (gameMode === 'earth') {

                                if (itemData.name === 'cash') updateCash(itemData.cash);

                                else if (itemData.name === 'obstacle') updateScore(itemData.value);

                            } else if (gameMode === 'space') {

                                if (itemData.name === 'upgrade') {

                                    if(gameState.spaceShipLevel < 2) gameState.spaceShipLevel++;

                                } else if (itemData.name === 'star') {

                                    updateScoreInSpace(itemData.value);

                                } else if (itemData.name === 'asteroid' || itemData.name === 'alien') {

                                    gameState.playerHealth--;

                                    updateHealthDisplay();

                                    if (gameState.playerHealth <= 0) gameOver();

                                }

                            }

                        }

            

                        function updateScore(change) {

                            const gameMode = LevelManager.getCurrentLevel();

                            if (gameMode === 'water' || gameMode === 'earth') {

                                gameState.score += change;

                                if (gameState.score < 0) gameState.score = 0;

                                ALL_ELEMENTS.score.textContent = gameState.score;

            

                                if (gameMode === 'water' && CONSTANTS.LEVEL_CONFIG[gameState.currentLevel] && gameState.score >= CONSTANTS.LEVEL_CONFIG[gameState.currentLevel].scoreForNext) {

                                    levelUp();

                                } else if (gameMode === 'earth' && gameMode === 'earth' && gameState.score >= 1000) {

                                    gameOver();

                                }

                            }

                        }

            

                        function updateScoreInSpace(points) {

                            const newScore = parseInt(ALL_ELEMENTS.score.textContent) + points;

                            ALL_ELEMENTS.score.textContent = newScore;

                            if (newScore >= 500) {

                                switchToNextLevel();

                            }

                        }

            

                        function updateCash(amount) {

                            gameState.cash += amount;

                            ALL_ELEMENTS.cash.textContent = `üí∞ ${gameState.cash}`;

                            const boatLevels = CONSTANTS.BOAT_LEVELS;

                            if (LevelManager.getCurrentLevel() === 'water' && gameState.currentBoatIndex < boatLevels.length - 1 && gameState.cash >= boatLevels[gameState.currentBoatIndex].cashForNext) {

                                gameState.currentBoatIndex++;

                                ALL_ELEMENTS.player.textContent = boatLevels[gameState.currentBoatIndex].emoji;

                                if (gameState.currentBoatIndex === boatLevels.length - 1) {

                                    setTimeout(switchToNextLevel, 2000);

                                }

                            }

                        }

            

                        function switchToNextLevel() {

                            if (!LevelManager.nextLevel()) {

                                gameOver();

                                return;

                            }

                            const levelModule = LevelManager.getCurrentLevelModule();

                            gameState.gameMode = LevelManager.getCurrentLevel();

            

                            document.body.style.background = levelModule.background;

                            if (gameState.gameMode === 'space') document.body.classList.add('space-mode');

                            else document.body.classList.remove('space-mode');

            

                            ALL_ELEMENTS.player.textContent = levelModule.playerEmoji;

                            document.querySelectorAll('.item').forEach(item => item.remove());

                            clearInterval(gameState.itemIntervalId);

                            const config = (gameState.gameMode === 'water') ? levelModule.config[gameState.currentLevel] : levelModule.config;

                            gameState.itemIntervalId = setInterval(createItem, config.itemInterval || 1000);

                            gameState.score = 0;

                            ALL_ELEMENTS.score.textContent = gameState.score;

            

                            if (gameState.gameMode === 'space') {

                                [ALL_ELEMENTS.level, ALL_ELEMENTS.cash, ALL_ELEMENTS.powerupStatus, ALL_ELEMENTS.water, ALL_ELEMENTS.instructions].forEach(el => el.classList.add('hidden'));

                                ALL_ELEMENTS.health.classList.remove('hidden');

                                updateHealthDisplay();

                                ALL_ELEMENTS.player.style.bottom = '5vh';

                                gameState.survivalScoreId = setInterval(() => updateScoreInSpace(1), 100);

                            } else if (gameState.gameMode === 'earth') {

                                ALL_ELEMENTS.player.style.left = '10%';

                                ALL_ELEMENTS.player.style.transform = 'none';

                                gameState.playerPositionY = 50;

                                ALL_ELEMENTS.player.style.bottom = `${gameState.playerPositionY}%`;

                            }

                        }

            function updateHealthDisplay() { ALL_ELEMENTS.health.textContent = '‚ù§Ô∏è'.repeat(gameState.playerHealth); }

            function gameOver() {
                clearInterval(gameState.itemIntervalId); clearInterval(gameState.survivalScoreId); cancelAnimationFrame(gameState.gameLoopId);
                ALL_ELEMENTS.gameOver.classList.remove('hidden');
            }

            function activateMagnet() {
                gameState.isMagnetActive = true;
                ALL_ELEMENTS.powerupStatus.textContent = 'üß≤';
                ALL_ELEMENTS.powerupStatus.classList.remove('hidden');
                clearTimeout(gameState.magnetTimerId);
                gameState.magnetTimerId = setTimeout(() => {
                    gameState.isMagnetActive = false;
                    ALL_ELEMENTS.powerupStatus.classList.add('hidden');
                }, CONSTANTS.MAGNET_DURATION);
            }

            function activateSlowDebuff() {
                gameState.isPlayerSlowed = true;
                ALL_ELEMENTS.water.classList.add('frozen');
                ALL_ELEMENTS.powerupStatus.textContent = 'ü•∂';
                ALL_ELEMENTS.powerupStatus.classList.remove('hidden');
                clearTimeout(gameState.slowTimerId);
                gameState.slowTimerId = setTimeout(() => {
                    gameState.isPlayerSlowed = false;
                    ALL_ELEMENTS.water.classList.remove('frozen');
                    ALL_ELEMENTS.powerupStatus.classList.add('hidden');
                }, CONSTANTS.SLOW_DURATION);
            }

            function handleMagnetPull() {
                if (!gameState.isMagnetActive) return;
                const playerRect = ALL_ELEMENTS.player.getBoundingClientRect();
                const playerCenterX = playerRect.left + playerRect.width / 2;
                const magnetRadiusPixels = (window.innerWidth * CONSTANTS.MAGNET_RADIUS_PERCENT) / 100;

                document.querySelectorAll('.item').forEach(item => {
                    const itemName = item.dataset.name;
                    if (itemName === 'trash' || itemName === 'powerup' || itemName === 'trap') return;

                    const itemRect = item.getBoundingClientRect();
                    const itemCenterX = itemRect.left + itemRect.width / 2;

                    if (Math.abs(playerCenterX - itemCenterX) < magnetRadiusPixels) {
                        const currentLeftPercent = parseFloat(item.style.left);
                        const playerCenterPercent = (playerCenterX / window.innerWidth) * 100;
                        const pullStrength = 0.1;
                        const newLeft = currentLeftPercent + (playerCenterPercent - currentLeftPercent) * pullStrength;
                        item.style.left = `${newLeft}%`;
                    }
                });
            }

            function shoot() {
                if (!gameState.canShoot || gameState.gameMode !== 'space') return;
                gameState.canShoot = false;
                setTimeout(() => gameState.canShoot = true, CONSTANTS.SHOOT_COOLDOWN);
                const playerRect = ALL_ELEMENTS.player.getBoundingClientRect();
                const offsets = (gameState.spaceShipLevel > 1) ? [-15, 15] : [0];
                offsets.forEach(offset => {
                    const projectile = document.createElement('div');
                    projectile.classList.add('projectile');
                    projectile.style.left = `${playerRect.left + (playerRect.width / 2) - 5 + offset}px`;
                    projectile.style.top = `${playerRect.top}px`;
                    ALL_ELEMENTS.gameContainer.appendChild(projectile);
                    gameState.projectiles.push(projectile);
                });
            }

            function updateProjectiles() {
                gameState.projectiles.forEach((p, index) => {
                    p.style.top = `${p.offsetTop - 15}px`;
                    if (p.offsetTop < 0) {
                        p.remove();
                        gameState.projectiles.splice(index, 1);
                        return;
                    }
                    document.querySelectorAll('.item[data-name="asteroid"], .item[data-name="alien"]').forEach(enemy => {
                        const pRect = p.getBoundingClientRect();
                        const eRect = enemy.getBoundingClientRect();
                        if (pRect.bottom > eRect.top && pRect.top < eRect.bottom && pRect.right > eRect.left && pRect.left < eRect.right) {
                            p.remove();
                            gameState.projectiles.splice(index, 1);
                            enemy.remove();
                            updateScoreInSpace(enemy.dataset.name === 'alien' ? 25 : 10);
                        }
                    });
                });
            }

            function updatePlayerPosition() {
                const currentSpeed = gameState.isPlayerSlowed ? gameState.playerSpeed * CONSTANTS.SLOW_FACTOR : gameState.playerSpeed;
                if (gameState.keysPressed.ArrowLeft) gameState.playerPosition -= currentSpeed;
                if (gameState.keysPressed.ArrowRight) gameState.playerPosition += currentSpeed;
                const playerWidth = (ALL_ELEMENTS.player.offsetWidth / window.innerWidth) * 100;
                gameState.playerPosition = Math.max(0, Math.min(100 - playerWidth, gameState.playerPosition));
                ALL_ELEMENTS.player.style.left = `${gameState.playerPosition}%`;
                ALL_ELEMENTS.player.style.transform = 'translateX(0)';
            }
            
            function gameLoop() {
                updatePlayerPosition();
                LevelManager.getCurrentLevelModule().update();
                gameState.gameLoopId = requestAnimationFrame(gameLoop);
            }

            function init() {
                const levelModule = LevelManager.getCurrentLevelModule();
                ALL_ELEMENTS.player.textContent = levelModule.playerEmoji;
                const config = (LevelManager.getCurrentLevel() === 'water') ? levelModule.config[gameState.currentLevel] : levelModule.config;
                gameState.itemIntervalId = setInterval(createItem, config.itemInterval || 1000);
                gameLoop();
            }

            window.addEventListener('keydown', (e) => { 
                if (gameState.keysPressed.hasOwnProperty(e.key)) gameState.keysPressed[e.key] = true;
            });
            window.addEventListener('keyup', (e) => { if (gameState.keysPressed.hasOwnProperty(e.key)) gameState.keysPressed[e.key] = false; });


            const testSpaceBtn = document.getElementById('test-space-btn');
            testSpaceBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent shooting when clicking the button
                switchToSpaceLevel();
            });

            ALL_ELEMENTS.gameContainer.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touchX = e.touches[0].clientX;
                const gameRect = ALL_ELEMENTS.gameContainer.getBoundingClientRect();
                const playerWidth = ALL_ELEMENTS.player.offsetWidth;
                let newPos = ((touchX - gameRect.left) / gameRect.width) * 100;
                const playerWidthPercent = (playerWidth / gameRect.width) * 100;
                gameState.playerPosition = newPos - playerWidthPercent / 2;
                const clampedPos = Math.max(0, Math.min(100 - playerWidthPercent, gameState.playerPosition));
                ALL_ELEMENTS.player.style.left = `${clampedPos}%`;
                ALL_ELEMENTS.player.style.transform = 'translateX(0)';
            }, { passive: false });

            init();
        });
    </script>
</body>
</html>
