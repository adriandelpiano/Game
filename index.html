<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Agua Abajo... y al Espacio!</title>
    <style>
        :root {
            --water-height: 20vh;
            --player-size: 10vmin;
            --item-size: 6vmin;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { width: 100%; height: 100%; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }
        body {
            background: linear-gradient(to bottom, #87CEEB 0%, #B2FFFF 80%);
            position: relative; display: flex; justify-content: center; align-items: center; flex-direction: column; transition: background 1s;
        }
        body.space-mode { background: #000; }
        #game-container { position: relative; width: 100%; height: 100%; max-width: 1000px; overflow: hidden; cursor: pointer; }

        #score, #level, #powerup-status, #cash, #health, #game-over {
            position: absolute; left: 15px; font-weight: bold; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); z-index: 100;
        }
        #score { top: 15px; font-size: 3em; }
        #level { top: 70px; font-size: 1.5em; }
        #powerup-status { top: 110px; font-size: 2em; }
        #cash { top: 150px; font-size: 1.5em; }
        #health { top: 15px; font-size: 2em; }
        #game-over { top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 3em; text-align: center; width: 100%; }

        #instructions { position: absolute; top: 20px; right: 20px; color: white; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); text-align: right; z-index: 100; }
        .hidden { display: none !important; }

        #water {
            position: absolute; bottom: 0; left: 0; width: 100%; height: var(--water-height);
            background-color: #1E90FF; overflow: hidden; transition: background-color 0.5s, opacity 1s;
        }
        #water.frozen { background-color: #AFEEEE; }
        #water.frozen::before, #water.frozen::after { animation-play-state: paused; opacity: 0.7; }
        #water::before, #water::after {
            content: ''; position: absolute; width: 200%; height: 100px; left: -50%; top: -50px;
            background-repeat: repeat-x; background-size: 50% 100px; animation: wave 10s linear infinite;
        }
        #water::before { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' preserveAspectRatio='none'%3E%3Cpath d='M0,50 C25,80 75,20 100,50 L100,100 L0,100 Z' fill='rgba(255,255,255,0.2)'/%3E%3C/svg%3E"); z-index: 10; }
        #water::after { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' preserveAspectRatio='none'%3E%3Cpath d='M0,60 C30,40 70,80 100,60 L100,100 L0,100 Z' fill='rgba(255,255,255,0.3)'/%3E%3C/svg%3E"); animation-direction: reverse; z-index: 9; }
        @keyframes wave { 0% { transform: translateX(0); } 100% { transform: translateX(-50%); } }

        #player {
            position: absolute; width: var(--player-size); height: var(--player-size); bottom: calc(var(--water-height) - (var(--player-size) / 2)); left: 50%;
            transform: translateX(-50%); font-size: calc(var(--player-size) * 0.8); text-align: center; line-height: var(--player-size); z-index: 20; transition: left 0.1s linear, bottom 1s;
        }
        .item { position: absolute; width: var(--item-size); height: var(--item-size); font-size: calc(var(--item-size) * 0.9); text-align: center; line-height: var(--item-size); user-select: none; z-index: 5; transition: left 0.2s linear; }
        .projectile { position: absolute; width: 10px; height: 25px; background-color: #FFD700; border-radius: 5px; z-index: 15; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="score">0</div>
        <div id="level">Nivel: 1</div>
        <div id="powerup-status" class="hidden"></div>
        <div id="cash">üí∞ 0</div>
        <div id="health" class="hidden"></div>
        <div id="game-over" class="hidden">GAME OVER</div>
        <div id="instructions">
            <p>‚Üê ‚Üí para mover</p>
            <p>Toca para mover en m√≥vil</p>
        </div>
        <div id="player"></div>
        <div id="water"></div>
        <button id="test-space-btn" style="position:absolute; top:10px; right:150px; z-index:200; padding: 5px; background: #fff; border: 1px solid #000; cursor: pointer;">Test Space Level</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const ALL_ELEMENTS = {
                gameContainer: document.getElementById('game-container'),
                player: document.getElementById('player'),
                score: document.getElementById('score'),
                level: document.getElementById('level'),
                powerupStatus: document.getElementById('powerup-status'),
                cash: document.getElementById('cash'),
                water: document.getElementById('water'),
                health: document.getElementById('health'),
                gameOver: document.getElementById('game-over'),
                instructions: document.getElementById('instructions')
            };

            let gameState = {
                gameMode: 'water', score: 0, cash: 0, currentLevel: 1, currentBoatIndex: 0, playerPosition: 50, playerHealth: 3, spaceShipLevel: 1,
                playerSpeed: 2, itemIntervalId: null, gameLoopId: null, survivalScoreId: null, canShoot: true,
                isMagnetActive: false, magnetTimerId: null, isPlayerSlowed: false, slowTimerId: null,
                projectiles: [], keysPressed: { ArrowLeft: false, ArrowRight: false, ' ': false }
            };

            const CONSTANTS = {
                MAGNET_DURATION: 8000, MAGNET_RADIUS_PERCENT: 25, SLOW_DURATION: 7000, SLOW_FACTOR: 0.5, SHOOT_COOLDOWN: 400,
                BOAT_LEVELS: [ { emoji: 'üö§', cashForNext: 100 }, { emoji: 'üõ•Ô∏è', cashForNext: 250 }, { emoji: 'üõ≥Ô∏è', cashForNext: 500 }, { emoji: '‚õ¥Ô∏è', cashForNext: 1000 } ],
                LEVEL_CONFIG: { 1: { scoreForNext: 100, itemInterval: 1500, minSpeed: 1, maxSpeed: 3 }, 2: { scoreForNext: 300, itemInterval: 1200, minSpeed: 1.5, maxSpeed: 4 }, 3: { scoreForNext: 600, itemInterval: 900, minSpeed: 2, maxSpeed: 5 }, 4: { scoreForNext: 1000, itemInterval: 700, minSpeed: 2.5, maxSpeed: 6 }, 5: { scoreForNext: 1500, itemInterval: 500, minSpeed: 3, maxSpeed: 7 } },
                WATER_ITEM_TYPES: [ { emoji: 'üíé', value: 50, name: 'treasure' }, { emoji: 'üçé', value: 10, name: 'fruit' }, { emoji: 'üçå', value: 10, name: 'fruit' }, { emoji: 'üí∞', value: 0, cash: 50, name: 'cash', chance: 0.2 }, { emoji: 'üóëÔ∏è', value: -25, name: 'trash' }, { emoji: 'üë¢', value: -10, name: 'trash' }, { emoji: 'üß≤', value: 0, name: 'powerup', subType: 'magnet', chance: 0.1 }, { emoji: 'üßä', value: -5, name: 'trap', subType: 'freeze', chance: 0.05 } ],
                SPACE_ITEM_TYPES: [ { emoji: '‚òÑÔ∏è', name: 'asteroid', chance: 0.85 }, { emoji: 'üëΩ', name: 'alien', chance: 0.1 }, { emoji: 'üî©', name: 'upgrade', chance: 0.05 } ]
            };

            function createItem() {
                const itemData = (gameState.gameMode === 'water') ? getRandomItem(CONSTANTS.WATER_ITEM_TYPES) : getRandomItem(CONSTANTS.SPACE_ITEM_TYPES);
                const itemElement = document.createElement('div');
                itemElement.classList.add('item');
                itemElement.dataset.name = itemData.name;
                if(itemData.subType) itemElement.dataset.subType = itemData.subType;
                itemElement.textContent = itemData.emoji;
                const config = (gameState.gameMode === 'water') ? CONSTANTS.LEVEL_CONFIG[gameState.currentLevel] : { minSpeed: 2, maxSpeed: 8 };
                const speed = Math.random() * (config.maxSpeed - config.minSpeed) + config.minSpeed;
                itemElement.style.left = `${Math.random() * 95}%`;
                itemElement.style.top = `-${parseInt(getComputedStyle(itemElement).height)}px`;
                ALL_ELEMENTS.gameContainer.appendChild(itemElement);
                moveItem(itemElement, speed, itemData);
            }

            function getRandomItem(itemSet) {
                const rand = Math.random();
                let cumulativeChance = 0;
                const itemsWithChance = itemSet.filter(t => t.chance);
                const regularItems = itemSet.filter(t => !t.chance);
                for (const item of itemsWithChance) {
                    cumulativeChance += item.chance;
                    if (rand < cumulativeChance) return item;
                }
                return regularItems[Math.floor(Math.random() * regularItems.length)];
            }

            function moveItem(element, speed, itemData) {
                let topPosition = element.offsetTop;
                function frame() {
                    topPosition += speed;
                    element.style.top = `${topPosition}px`;
                    const playerRect = ALL_ELEMENTS.player.getBoundingClientRect();
                    const itemRect = element.getBoundingClientRect();
                    if (itemRect.bottom > playerRect.top && itemRect.top < playerRect.bottom && itemRect.right > playerRect.left && itemRect.left < playerRect.right) {
                        handleCollision(itemData, element);
                        return;
                    }
                    if (topPosition > window.innerHeight) { element.remove(); return; }
                    requestAnimationFrame(frame);
                }
                requestAnimationFrame(frame);
            }

            function handleCollision(itemData, itemElement) {
                itemElement.remove();
                if (gameState.gameMode === 'water') {
                    if (itemData.name === 'powerup' && itemData.subType === 'magnet') activateMagnet();
                    else if (itemData.name === 'trap' && itemData.subType === 'freeze') activateSlowDebuff();
                    else if (itemData.name === 'cash') updateCash(itemData.cash);
                    else updateScore(itemData.value);
                } else if (gameState.gameMode === 'space') {
                    if (itemData.name === 'upgrade') {
                        if(gameState.spaceShipLevel < 2) gameState.spaceShipLevel++;
                    } else if (itemData.name === 'asteroid' || itemData.name === 'alien') {
                        gameState.playerHealth--;
                        updateHealthDisplay();
                        if (gameState.playerHealth <= 0) gameOver();
                    }
                }
            }

            function updateScore(change) {
                if (gameState.gameMode !== 'water') return;
                gameState.score += change;
                if (gameState.score < 0) gameState.score = 0;
                ALL_ELEMENTS.score.textContent = gameState.score;
                if (gameState.score >= CONSTANTS.LEVEL_CONFIG[gameState.currentLevel].scoreForNext) levelUp();
            }
            
            function updateScoreInSpace(points) {
                ALL_ELEMENTS.score.textContent = parseInt(ALL_ELEMENTS.score.textContent) + points;
            }

            function updateCash(amount) {
                gameState.cash += amount;
                ALL_ELEMENTS.cash.textContent = `üí∞ ${gameState.cash}`;
                const boatLevels = CONSTANTS.BOAT_LEVELS;
                if (gameState.currentBoatIndex < boatLevels.length - 1 && gameState.cash >= boatLevels[gameState.currentBoatIndex].cashForNext) {
                    gameState.currentBoatIndex++;
                    ALL_ELEMENTS.player.textContent = boatLevels[gameState.currentBoatIndex].emoji;
                    if (gameState.currentBoatIndex === boatLevels.length - 1) {
                        setTimeout(switchToSpaceLevel, 2000);
                    }
                }
            }

            function levelUp() {
                const config = CONSTANTS.LEVEL_CONFIG;
                if (gameState.gameMode !== 'water' || !config[gameState.currentLevel] || !config[gameState.currentLevel].scoreForNext) return;
                if (gameState.score >= config[gameState.currentLevel].scoreForNext) {
                    gameState.currentLevel++;
                    ALL_ELEMENTS.level.textContent = `Nivel: ${gameState.currentLevel}`;
                    clearInterval(gameState.itemIntervalId);
                    gameState.itemIntervalId = setInterval(createItem, config[gameState.currentLevel].itemInterval);
                }
            }

            function switchToSpaceLevel() {
                gameState.gameMode = 'space';
                document.body.classList.add('space-mode');
                [ALL_ELEMENTS.level, ALL_ELEMENTS.cash, ALL_ELEMENTS.powerupStatus, ALL_ELEMENTS.water, ALL_ELEMENTS.instructions].forEach(el => el.classList.add('hidden'));
                ALL_ELEMENTS.health.classList.remove('hidden');
                ALL_ELEMENTS.score.textContent = '0';
                updateHealthDisplay();
                ALL_ELEMENTS.player.textContent = 'üöÄ';
                ALL_ELEMENTS.player.style.bottom = '5vh';
                document.querySelectorAll('.item').forEach(item => item.remove());
                clearInterval(gameState.itemIntervalId);
                gameState.itemIntervalId = setInterval(createItem, 400);
                gameState.survivalScoreId = setInterval(() => updateScoreInSpace(1), 100);
            }

            function updateHealthDisplay() { ALL_ELEMENTS.health.textContent = '‚ù§Ô∏è'.repeat(gameState.playerHealth); }

            function gameOver() {
                clearInterval(gameState.itemIntervalId); clearInterval(gameState.survivalScoreId); cancelAnimationFrame(gameState.gameLoopId);
                ALL_ELEMENTS.gameOver.classList.remove('hidden');
            }

            function activateMagnet() {
                gameState.isMagnetActive = true;
                ALL_ELEMENTS.powerupStatus.textContent = 'üß≤';
                ALL_ELEMENTS.powerupStatus.classList.remove('hidden');
                clearTimeout(gameState.magnetTimerId);
                gameState.magnetTimerId = setTimeout(() => {
                    gameState.isMagnetActive = false;
                    ALL_ELEMENTS.powerupStatus.classList.add('hidden');
                }, CONSTANTS.MAGNET_DURATION);
            }

            function activateSlowDebuff() {
                gameState.isPlayerSlowed = true;
                ALL_ELEMENTS.water.classList.add('frozen');
                ALL_ELEMENTS.powerupStatus.textContent = 'ü•∂';
                ALL_ELEMENTS.powerupStatus.classList.remove('hidden');
                clearTimeout(gameState.slowTimerId);
                gameState.slowTimerId = setTimeout(() => {
                    gameState.isPlayerSlowed = false;
                    ALL_ELEMENTS.water.classList.remove('frozen');
                    ALL_ELEMENTS.powerupStatus.classList.add('hidden');
                }, CONSTANTS.SLOW_DURATION);
            }

            function handleMagnetPull() {
                if (!gameState.isMagnetActive) return;
                const playerRect = ALL_ELEMENTS.player.getBoundingClientRect();
                const playerCenterX = playerRect.left + playerRect.width / 2;
                const magnetRadiusPixels = (window.innerWidth * CONSTANTS.MAGNET_RADIUS_PERCENT) / 100;

                document.querySelectorAll('.item').forEach(item => {
                    const itemName = item.dataset.name;
                    if (itemName === 'trash' || itemName === 'powerup' || itemName === 'trap') return;

                    const itemRect = item.getBoundingClientRect();
                    const itemCenterX = itemRect.left + itemRect.width / 2;

                    if (Math.abs(playerCenterX - itemCenterX) < magnetRadiusPixels) {
                        const currentLeftPercent = parseFloat(item.style.left);
                        const playerCenterPercent = (playerCenterX / window.innerWidth) * 100;
                        const pullStrength = 0.1;
                        const newLeft = currentLeftPercent + (playerCenterPercent - currentLeftPercent) * pullStrength;
                        item.style.left = `${newLeft}%`;
                    }
                });
            }

            function shoot() {
                if (!gameState.canShoot || gameState.gameMode !== 'space') return;
                gameState.canShoot = false;
                setTimeout(() => gameState.canShoot = true, CONSTANTS.SHOOT_COOLDOWN);
                const playerRect = ALL_ELEMENTS.player.getBoundingClientRect();
                const offsets = (gameState.spaceShipLevel > 1) ? [-15, 15] : [0];
                offsets.forEach(offset => {
                    const projectile = document.createElement('div');
                    projectile.classList.add('projectile');
                    projectile.style.left = `${playerRect.left + (playerRect.width / 2) - 5 + offset}px`;
                    projectile.style.top = `${playerRect.top}px`;
                    ALL_ELEMENTS.gameContainer.appendChild(projectile);
                    gameState.projectiles.push(projectile);
                });
            }

            function updateProjectiles() {
                gameState.projectiles.forEach((p, index) => {
                    p.style.top = `${p.offsetTop - 15}px`;
                    if (p.offsetTop < 0) {
                        p.remove();
                        gameState.projectiles.splice(index, 1);
                        return;
                    }
                    document.querySelectorAll('.item[data-name="asteroid"], .item[data-name="alien"]').forEach(enemy => {
                        const pRect = p.getBoundingClientRect();
                        const eRect = enemy.getBoundingClientRect();
                        if (pRect.bottom > eRect.top && pRect.top < eRect.bottom && pRect.right > eRect.left && pRect.left < eRect.right) {
                            p.remove();
                            gameState.projectiles.splice(index, 1);
                            enemy.remove();
                            updateScoreInSpace(enemy.dataset.name === 'alien' ? 25 : 10);
                        }
                    });
                });
            }

            function updatePlayerPosition() {
                const currentSpeed = gameState.isPlayerSlowed ? gameState.playerSpeed * CONSTANTS.SLOW_FACTOR : gameState.playerSpeed;
                if (gameState.keysPressed.ArrowLeft) gameState.playerPosition -= currentSpeed;
                if (gameState.keysPressed.ArrowRight) gameState.playerPosition += currentSpeed;
                const playerWidth = (ALL_ELEMENTS.player.offsetWidth / window.innerWidth) * 100;
                gameState.playerPosition = Math.max(0, Math.min(100 - playerWidth, gameState.playerPosition));
                ALL_ELEMENTS.player.style.left = `${gameState.playerPosition}%`;
                ALL_ELEMENTS.player.style.transform = 'translateX(0)';
            }
            
            function gameLoop() {
                updatePlayerPosition();
                if (gameState.gameMode === 'water') handleMagnetPull();
                else if (gameState.gameMode === 'space') {
                    updateProjectiles();
                    shoot();
                }
                gameState.gameLoopId = requestAnimationFrame(gameLoop);
            }

            function init() {
                ALL_ELEMENTS.player.textContent = CONSTANTS.BOAT_LEVELS[gameState.currentBoatIndex].emoji;
                gameState.itemIntervalId = setInterval(createItem, CONSTANTS.LEVEL_CONFIG[gameState.currentLevel].itemInterval);
                gameLoop();
            }

            window.addEventListener('keydown', (e) => { 
                if (gameState.keysPressed.hasOwnProperty(e.key)) gameState.keysPressed[e.key] = true;
            });
            window.addEventListener('keyup', (e) => { if (gameState.keysPressed.hasOwnProperty(e.key)) gameState.keysPressed[e.key] = false; });


            const testSpaceBtn = document.getElementById('test-space-btn');
            testSpaceBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent shooting when clicking the button
                switchToSpaceLevel();
            });

            ALL_ELEMENTS.gameContainer.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touchX = e.touches[0].clientX;
                const gameRect = ALL_ELEMENTS.gameContainer.getBoundingClientRect();
                const playerWidth = ALL_ELEMENTS.player.offsetWidth;
                let newPos = ((touchX - gameRect.left) / gameRect.width) * 100;
                const playerWidthPercent = (playerWidth / gameRect.width) * 100;
                gameState.playerPosition = newPos - playerWidthPercent / 2;
                const clampedPos = Math.max(0, Math.min(100 - playerWidthPercent, gameState.playerPosition));
                ALL_ELEMENTS.player.style.left = `${clampedPos}%`;
                ALL_ELEMENTS.player.style.transform = 'translateX(0)';
            }, { passive: false });

            init();
        });
    </script>
</body>
</html>
